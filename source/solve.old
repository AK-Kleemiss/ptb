      subroutine solve(ndim,nel,nopen,et,focc,H,S,P,e,ge,fail)
      implicit none
      integer ndim,nel,nopen
      real*8 H(ndim*(ndim+1)/2)
      real*8 S(ndim*(ndim+1)/2)
      real*8 P(ndim*(ndim+1)/2)
      real*8 e(ndim)
      real*8 focc(ndim)
      real*8 ge        
      real*8 et        
      logical fail

      integer i,j,info,lwork,liwork,nfound,ij     
      integer ihomoa,ihomob
      real*8 nfoda,nfodb,ga,gb,efa,efb
      integer,allocatable ::iwork(:),ifail(:)
      real*8 ,allocatable ::aux  (:), hdum(:,:),sdum(:,:)
      real*8 ,allocatable ::focca(:), foccb(:)

      fail =.false.
      allocate (hdum(ndim,ndim),sdum(ndim,ndim),focca(ndim),foccb(ndim))

      call blowsym(ndim,H,hdum)
      call blowsym(ndim,S,sdum)
      allocate (aux(1),iwork(1),ifail(ndim))
      call DSYGVD(1,'V','U',ndim,hdum,ndim,sdum,ndim,e,aux,  !workspace query
     .           -1,IWORK,LIWORK,INFO)
      lwork=int(aux(1))
      liwork=iwork(1)
      deallocate(aux,iwork)
      allocate (aux(lwork),iwork(liwork))              !do it
      call DSYGVD(1,'V','U',ndim,hdum,ndim,sdum,ndim,e,aux,
     .            LWORK,IWORK,LIWORK,INFO)
      if(info.ne.0) fail=.true.

      ga=0
      gb=0
c Fermi smearing                                          
c     convert restricted occ first to alpha/beta             
      if(nel.gt.0) then
         call occu(ndim,nel,nopen,ihomoa,ihomob,focca,foccb)
      else
         focca=0.0d0
         foccb=0.0d0
         ihomoa=0
         ihomob=0
      endif
      if(ihomoa+1.le.ndim) then 
         call FERMISMEAR(.false.,ndim,ihomoa,et,e,focca,nfoda,efa,ga)
      endif
      if(ihomob+1.le.ndim.and.nel.gt.1) then
         call FERMISMEAR(.false.,ndim,ihomob,et,e,foccb,nfodb,efb,gb)
      endif
      focc = focca + foccb
      ge = ga + gb

      call dmat(ndim,focc,hdum,sdum)
      call packsym(ndim,sdum,P)

      end

!ccccccccccccccccccccccccccccccccccccccccccccc

      subroutine blowsym(n,matin,matout)
      implicit none
      integer n
      real*8 matin (n*(n+1)/2)
      real*8 matout(n,n)      
      integer i,j,ij

      ij = 0
      do i=1,n
         do j=1,i
            ij = ij + 1
            matout(j,i)=matin(ij)
            matout(i,j)=matin(ij)
         enddo
      enddo

      end

      subroutine packsym(n,matin,matout)
      implicit none
      integer n
      real*8 matout(n*(n+1)/2)
      real*8 matin (n,n)      
      integer i,j,ij

      ij = 0
      do i=1,n
         do j=1,i
            ij = ij + 1
            matout(ij)=matin(j,i)
         enddo
      enddo

      end

!ccccccccccccccccccccccccccccccccccccccccccccc
! density matrix
! C   : MO coefficient
! focc: occupations      
! P  dmat
!ccccccccccccccccccccccccccccccccccccccccccccc

      subroutine dmat(ndim,focc,C,P)
      implicit none
      integer ndim
      real*8 focc(*)
      real*8 C(ndim,ndim)
      real*8 P(ndim,ndim)
      integer i,m
      real*8,allocatable ::Ptmp(:,:)
              
      allocate(Ptmp(ndim,ndim))                  
      do m=1,ndim  
         do i=1,ndim
            Ptmp(i,m)=C(i,m)*focc(m)
         enddo
      enddo
      call DGEMM('N','T',ndim,ndim,ndim,1.0d0,C,
     .                   ndim,Ptmp,ndim,0.0d0,P,ndim)
      deallocate(Ptmp)

      end

