!! ------------------------------------------------------------------------
! model Hamiltonian to provide atomic shell populations and density matrix
! fitted to Mulliken DFT populations/q/BO/dipole
! SG, 2020-2021
! last change on method and fit parameters Tue Jun 27 08:52:20 CEST 2021
! HCNO FIT RMSD 15.46
!! ------------------------------------------------------------------------

subroutine shellq(pr,prop,n,ndim,nel,nopen,homo,at,chrg,xyz,z,rab, & 
&                 pnt,norm,S,psh,pa,P,wbo,dip,alp)
   use iso_fortran_env, only : wp => real64
   use parcom
   use bascom
   use com
   implicit none

!! ------------------------------------------------------------------------
!  Input
!! ------------------------------------------------------------------------
   logical, intent(in)    :: pr                 ! print
   integer, intent(in)    :: prop               ! type of property calc (0: p,q,P,WBO   1: +dip  2: + polar)
   integer, intent(in)    :: n                  ! number of atoms 
   integer, intent(in)    :: ndim               ! number of AOs       
   integer, intent(in)    :: nel                ! number of electrons 
   integer, intent(in)    :: nopen              ! number of open shells
   integer, intent(in)    :: homo               ! as the name says...
   integer, intent(in)    :: at(n)              ! ordinal number of atoms
   real(wp),intent(in)    :: chrg               ! system charge           
   real(wp),intent(in)    :: xyz(3,n)           ! coordinates (not used)
   real(wp),intent(in)    :: z(n)               ! nuclear charges          
   real(wp),intent(in)    :: rab(n*(n+1)/2)     ! distances  
   real(wp),intent(in)    :: pnt(3)             ! property reference point
   real(wp),intent(in)    :: norm(ndim)         ! SAO normalization factors
   real(wp),intent(in)    :: S(ndim*(ndim+1)/2) ! exact overlap maxtrix in SAO
!! ------------------------------------------------------------------------
!  Output
!! ------------------------------------------------------------------------
   real(wp),intent(out)   :: psh(10,n)          ! shell populations 
   real(wp),intent(out)   :: pa(n)              ! atom      "
   real(wp),intent(out)   :: P(ndim*(ndim+1)/2) ! density matrix
   real(wp),intent(out)   :: wbo(n,n)           ! WBOs                 
   real(wp),intent(out)   :: dip(3)             ! dipole moment
   real(wp),intent(out)   :: alp(6)             ! dipole polarizability tensor

!! ------------------------------------------------------------------------
!  charge model, local
!! ------------------------------------------------------------------------
   real(wp),allocatable :: Hmat (:)                  ! Hamiltonian matrix
   real(wp),allocatable :: Hdiag(:)                  ! diagonal
   real(wp),allocatable :: SS(:)                     ! scaled overlap/perturbed H
   real(wp),allocatable :: eps(:)                    ! eigenvalues
   real(wp),allocatable :: focc(:)                   ! occupations

   real(wp),allocatable :: d  (:,:)                  ! dipole integrals
   real(wp),allocatable :: P1   (:)                  ! perturbed P     
   real(wp)             :: dip1(3),dip2(3)
   real(wp)             :: alpha(3,3)         

!  global fit para
   real(wp),parameter   :: eT     = 300.00_wp   ! electronic temp. 
   real(wp),parameter   :: erfs   =-2.0000_wp   ! erf expo CN 
   real(wp),parameter   :: gamscal= 1.1000_wp   ! global gamma scaling
!  real(wp),parameter   :: pscal1 = 0.4614_wp   ! Ves scal atomic
   integer ,parameter   :: maxiter= 2              


!! ------------------------------------------------------------------------
!  local variables
!! ------------------------------------------------------------------------
   integer  :: i,j,k,l,ish,ati,atj,ia,ib,jsh,ii,jj,lin,ij,li,ihomoa,ihomob
   integer  :: ns, iter
   integer  :: llao(4)
   integer  :: itabrow6, ir, jr
   data llao /1,3,5,7 /
   real(wp) :: r,rcovij,arg,tmp,hi,hj,hij,pol,eh1,xk,sk,t8,t9,gpol(2)
   real(wp) :: qscal2, pscal1, keht(6), jexp, qa, qb
   real(wp),allocatable :: cn(:), cns(:), gab(:,:), gq(:), ves(:,:), gama(:)
   real(wp),allocatable :: S1(:,:), S2(:,:) !, X(:,:)
   logical fail

!! ------------------------------------------------------------------------
!  initizialization
!! ------------------------------------------------------------------------
   if(pr)then
   write(*,*) '----------------'
   write(*,*) '| shellQ model |'
   write(*,*) '| SG 2020-2021 |'
   write(*,*) '----------------'
   endif

   allocate( S1(ndim,ndim),S2(ndim,ndim) )   ! ,X(ndim,ndim))

   call mlpop1(ndim,S,S1,S2) ! ML precalc, x=1/4
   if(pr)write(*,*) 'ML setup done.'

   allocate( Hmat(ndim*(ndim+1)/2), Hdiag(ndim), focc(ndim), SS(ndim*(ndim+1)/2), eps(ndim), &
  &          gama(n), ves(10,n), gq(n), gab(n,n), cn(n), cns(n), source = 0.0_wp )

! for fit
   gpol(1)  = glob_par(1)
   gpol(2)  = glob_par(2)
   qscal2   = glob_par(3)
   pscal1   = glob_par(4)
   keht(1)  = glob_par(5)
   keht(2)  = glob_par(6) 
   keht(3)  = keht(2)-0.14
   keht(4)  = keht(3)-0.14
   keht(5)  = keht(4)-0.14
   keht(6)  = keht(5)-0.14
   jexp     = glob_par(7) 

!  def CN
   call ncoord_erf(n,at,rab,-2.0_wp,cns) ! the org. EEQ was parameterized with erfs=-7.5
!  def EEQ charges pa in first iter
   call eeq(n,at,rab,chrg,cns,pa)

   if(pr)then
   write(*,*) 'EEQ done.'
   write(*,'(''sum q : '',f8.3)') sum(pa)
   write(*,'(''   atom      EEQ charges     defCN       specCN'')')
   endif

!  special CN
   cn = 0_wp
   do i = 2, n
      do j = 1, i-1 
         r = rab(lin(i,j))
         rcovij=shell_cnf4(3,at(i))+shell_cnf4(3,at(j))
         arg = (r-rcovij)/rcovij
         tmp = 0.5_wp * (1_wp + erf(erfs*arg)) 
         cn(i) = cn(i) + tmp      
         cn(j) = cn(j) + tmp 
      enddo
   enddo
   if(pr)then
   do i=1,n
       write(*,'(2i5,4f12.4)') i,at(i),pa(i),cns(i),cn(i),cns(i)/(cn(i)+0.001_wp)
   enddo
   endif

!  DFTB second order term J matrix
   do i=1, n
      gama(i) = 0.5_wp/(gam(at(i)) * gamscal * (1_wp+cn(i)*shell_cnf4(7,at(i)))) ! scaled standard hardness
   enddo

   k = 0
   do i=1, n
      do j=1,i
         k = k + 1
         xk=gama(i)+gama(j)                  ! av.
         gab(j,i)=1_wp/(rab(k)**jexp+xk**jexp)**(1_wp/jexp) ! damped Coulomb
         gab(i,j)=gab(j,i)
      enddo
   enddo

   call modbas(n,at,3) 
   call sint(n,ndim,at,xyz,rab,SS,eps)    ! scaled S 

   ! atomic H0        
   ii = 0
   do i = 1, n
      ati = at(i)
      do ish=1,bas_nsh(ati)
          tmp = shell_xi(ish,ati) + cn(i)*shell_cnf1(ish,ati) ! shell-wise + shell-wise CN
          l = bas_lsh(ish,ati)+1
          do j=1,llao(l)                                      ! AO loop
             ii = ii + 1
             Hdiag(ii) = tmp
          enddo
      enddo
   enddo

!! ------------------------------------------------------------------------
!  set up the H matrix twice
!! ------------------------------------------------------------------------

   do iter=1, maxiter   ! two "iterations": in the first, q = q(EEQ)

   if(iter.eq.1) then   ! atom-wise ES, no shell pop available
      do i=1, n
         eh1 = 0_wp
         do l=1,n
            eh1=eh1+pa(l)*gab(l,i)  ! contraction with charge (DFTB term)
         enddo
         gq(i) = eh1 * pscal1 *0.5_wp * (1_wp+chrg*0.05)
      enddo
   else                  ! shell-wise xTB like
      call setespot(n,at,psh,gab,ves) 
      ves = ves * 0.5_wp
   endif    

! H0 +  third-order (atomic charge exists in 1. and 2. iter)
   ij = 0
   Hmat=0
   do i=1,ndim
      ia = aoat(i)
      ati= at(ia)
      ir = itabrow6(ati)
      ish= shell2ao(i)
      li = bas_lsh(ish,ati)+1
      hi = Hdiag(i)
      t8 = pa(ia)**2*shell_cnf4(1,ati)
      do j=1,i  
         ij = ij + 1
         if(abs(S(ij)).lt.1.d-7) cycle
         ib = aoat(j)
         hj = Hdiag(j)
         hij= hi+hj
         atj= at(ib)
         if(ia.ne.ib) then            ! different atoms
            jr  = itabrow6(atj)
            r   = rab(lin(ia,ib))
            xk  = shell_cnf4(2,ati)+shell_cnf4(2,atj)
            pol = ((hi-hj)/hij)**2
            tmp = 0.5_wp*(keht(ir)+keht(jr)) * SS(ij) * hij * (1_wp-pol*gpol(iter)) * (1_wp+xk/r)
         else                         ! same atoms
            tmp = SS(ij) * hij
            jsh = shell2ao(j)
            if(ish.ne.jsh) then       ! s-s', p-p' off-diagonal (there is no d-d' in MG VDZP)
               tmp = tmp * shell_cnf4(3+li,ati)  ! li=lj because S=0 otherwise
            endif
         endif
         t9=pa(ib)**2*shell_cnf4(1,atj)
         Hmat(ij) = tmp - S(ij)*(t8+t9) ! third order diagonal
      enddo
   enddo

! H1
   if(iter.eq.1)then ! atom-wise, no +U (no P exists)
   ij = 0
   do i=1,ndim
      ia = aoat(i)
      do j=1,i  
         ib = aoat(j)
         ij = ij + 1
         Hmat(ij) = Hmat(ij) - (gq(ia)+gq(ib)) * S(ij) 
      enddo
   enddo
   else 
! shell-wise ES + U terms with density from 1. iter
   k = 0
   do i=1,ndim
      ia = aoat(i)
      ati= at(ia)
      ish= shell2ao(i)
      qa = pa(ia)+qscal2*pa(ia)**2
      hi = shell_cnf2(ish,ati)*(1_wp-qa*shell_cnf4(8,ati)) ! important charge scaling
      do j=1,i
         k  = k + 1
         ib = aoat(j)
         atj= at(ib)
         jsh= shell2ao(j)
         qb = pa(ib)+qscal2*pa(ib)**2
         hj = shell_cnf2(jsh,atj)*(1_wp-qb*shell_cnf4(8,atj))
         xk = (hi + hj)                                                    ! * (1_wp+gab(ib,ia)*glob_par(6))
         Hmat(k) = Hmat(k) + P(k) * xk - S(k)*(ves(ish,ia)+ves(jsh,ib))
      enddo
   enddo
   endif

   if(pr)write(*,*) 'shellQ H matrix iteration ',iter, ' done. Now diag ...'

!  solve 
   call solve (ndim,nel,nopen,homo,eT,focc,Hmat,S,P,eps,eh1,fail)
   if(fail) stop 'diag error'

   if(iter.gt.1.and.pr)then
     ii=max(homo-2,1)
     jj=min(homo+2,ndim)
     write(*,'('' frontier occ.: '',10f8.3)') focc(ii:jj)
     write(*,'('' gap          : '',  f8.3)') eps(homo+1)-eps(homo)
     if(eps(homo+1)-eps(homo).lt.0.02) write(*,*) 'WARNING: small HL gap!'
   endif

!  pop
   call mlpop2(n,ndim, P, S1, S2, pa, psh)
   if(iter.lt.maxiter) pa = z - pa

   enddo
!! ------------------------------------------------------------------------
!  done
!! ------------------------------------------------------------------------

! properties: WBO
   call wiberg(n,ndim,at,rab,P,S,wbo)

! properties: dipole moment
   if(prop.eq.1.or.prop.eq.2)then
     allocate(d(ndim*(ndim+1)/2,3))
     call modbas(n,at,4) 
     call dipint(n,ndim,at,xyz,rab,norm,pnt,d)   ! dipole integrals
     call dipmom2(n,ndim,xyz,z,norm,P,d,pnt,dip) ! get dipole moment
   endif

! properties: polarizability
   if(prop.eq.2)then
     xk  = 0.0005_wp  ! finite field step
     allocate(P1(ndim*(ndim+1)/2))
     pol=0
     do k=1,3
        call addsym(ndim, xk,Hmat,d(1,k),SS) ! perturb H
        call solve (ndim,nel,nopen,homo,eT,focc,SS,S,P1,eps,eh1,fail) ! solve
        call dipmom2(n,ndim,xyz,z,norm,P1,d,pnt,dip1) ! get new dipole moment
        call addsym(ndim,-xk,Hmat,d(1,k),SS) ! other direction
        call solve (ndim,nel,nopen,homo,eT,focc,SS,S,P1,eps,eh1,fail)
        call dipmom2(n,ndim,xyz,z,norm,P1,d,pnt,dip2)
        alpha(k,1:3)=-(dip1(1:3)-dip2(1:3))/(2_wp*xk) ! numerical diff. dmu/dfield
        pol = pol + alpha(k,k)
     enddo
     pol = pol / 3_wp
     if(abs(alpha(1,2)-alpha(2,1))/pol.gt.1d-2) stop 'tensor not symmetric1'
     if(abs(alpha(1,3)-alpha(3,1))/pol.gt.1d-2) stop 'tensor not symmetric2'
     if(abs(alpha(2,3)-alpha(3,2))/pol.gt.1d-2) stop 'tensor not symmetric3'
     alp(1)=alpha(1,1)
     alp(2)=0.5*(alpha(2,1)+alpha(1,2))
     alp(3)=alpha(2,2)
     alp(4)=0.5*(alpha(3,1)+alpha(1,3))
     alp(5)=0.5*(alpha(3,2)+alpha(2,3))
     alp(6)=alpha(3,3)
   endif

   end

!! ------------------------------------------------------------------------
!  set up Coulomb potential due to 2nd order fluctuation shell-wise
!! ------------------------------------------------------------------------

subroutine setespot(n,at,qsh,jab,ves)
   use bascom
      implicit none 
      integer, intent(in)  :: n
      integer, intent(in)  :: at(n)
      real*8,  intent(in)  :: qsh(10,n),jab(n,n)
      real*8,  intent(out) :: ves(10,n) 

      integer i,j,ati,atj,ish,jsh
      real*8  vesi
      real*8  atocc(10)

      do i=1,n
         ati = at(i)
         do ish=1,bas_nsh(ati)
            vesi = 0
            do j=1,n   
               atj = at(j)
               do jsh=1,bas_nsh(atj)
                  call shellocc_ref(atj,atocc)           
                  vesi =vesi + (atocc(jsh)-qsh(jsh,j))*jab(j,i)
               enddo
            enddo
            ves(ish,i) = vesi
         enddo
      enddo

      end  

!! ------------------------------------------------------------------------
!! neutral atomic shell occupations from r2SCAN-3c opt 
!! C2H6, CH3NH2, CH3OH
!! ------------------------------------------------------------------------

subroutine shellocc_ML(at,socc) ! shellQ based on wB97X-D3 ML(x=1/4)              
      use bascom
      implicit none
      integer at
      real*8 socc(*)

      socc(1:bas_nsh(at))=0

      select case (at)

      case (1) 
      socc( 1)=  0.534480053175
      socc( 2)=  0.405818421323
      socc( 3)=  0.059701525502
      case (3) 
      case (4) 
      case (5) 
      case (6) 
      socc( 1)=  0.578446469175
      socc( 2)=  0.324052365218
      socc( 3)=  1.820045889629
      socc( 4)=  1.208313837682
      socc( 5)=  0.069141438297
      case (7)
      socc( 1)=  0.694358181161
      socc( 2)=  0.488055901112
      socc( 3)=  2.234490331290
      socc( 4)=  1.539185424727
      socc( 5)=  0.043910161710
      case (8)
      socc( 1)=  0.882602145531
      socc( 2)=  0.590942331986
      socc( 3)=  2.708428625644
      socc( 4)=  1.786865163528
      socc( 5)=  0.031161733311
      case (9)
      end select

      end

!! ------------------------------------------------------------------------
!! neutral atomic shell occupations from r2SCAN-3c opt 
!! C2H6, CH3NH2, CH3OH
!! ------------------------------------------------------------------------

subroutine shellocc_ref(at,socc) 
      use bascom
      implicit none
      integer at
      real*8 socc(*)

      socc(1:bas_nsh(at))=0

      select case (at)

      case (1) ! c2h6
      socc( 1)=  0.533047627235
      socc( 2)=  0.408579869489
      socc( 3)=  0.058372503276
      case (2) ! heh+ 
      socc( 1)=  1.281397706549
      socc( 2)=  0.713829552965
      socc( 3)=  0.004772740486
      case (3) ! lih
      socc( 1)=  0.409565688560
      socc( 2)=  0.191757285436
      socc( 3)=  0.340235870385
      socc( 4)=  0.018214263048
      socc( 5)=  0.040226892572
      case (4) ! beh2
      socc( 1)=  0.685947888116
      socc( 2)=  0.308621403483
      socc( 3)=  0.646526998702
      socc( 4)=  0.307851605051
      socc( 5)=  0.051052104648
      case (5) ! b2h6
      socc( 1)=  0.552106361608
      socc( 2)=  0.233899678096
      socc( 3)=  1.345854343178
      socc( 4)=  0.762030308127
      socc( 5)=  0.106109308991
      case (6) ! c2h6
      socc( 1)=  0.571201906704
      socc( 2)=  0.323220026328
      socc( 3)=  1.827270260662
      socc( 4)=  1.206087153721
      socc( 5)=  0.072220652586
      case (7) ! n2h4
      socc( 1)=  0.720109002669
      socc( 2)=  0.484216257374
      socc( 3)=  2.229217660006
      socc( 4)=  1.496949883845
      socc( 5)=  0.069507196105
      case (8) ! h2o2
      socc( 1)=  0.957139137702
      socc( 2)=  0.638574629300
      socc( 3)=  2.666173232804
      socc( 4)=  1.692500432213
      socc( 5)=  0.045612567981
      case (9) ! hf
      socc( 1)=  1.026161598808
      socc( 2)=  0.681838249673
      socc( 3)=  3.183619297124
      socc( 4)=  2.098069014104
      socc( 5)=  0.010311840291
      case (11) ! nah 
      socc( 1)=  0.059186811373
      socc( 2)=  0.553904448219
      socc( 3)=  0.312058923528
      socc( 4)=  0.017052854453
      socc( 5)=  0.057796962427
      case (12) ! mgh2  
      socc( 1)=  0.658325322782
      socc( 2)=  0.396018507733
      socc( 3)=  0.703816562424
      socc( 4)=  0.138982936940
      socc( 5)=  0.102856670121
      case (13) ! al2h6
      socc( 1)=  0.633418917174
      socc( 2)=  0.336953861007
      socc( 3)=  1.372801277879
      socc( 4)=  0.424269888354
      socc( 5)=  0.232556055585
      case (14) ! si2h6
      socc( 1)=  0.668726898902
      socc( 2)=  0.458688273846
      socc( 3)=  1.980924392864
      socc( 4)=  0.728999352795
      socc( 5)=  0.162661081593
      case (15) ! p2h4
      socc( 1)=  0.803207509565
      socc( 2)=  0.748576826399
      socc( 3)=  2.527289576203
      socc( 4)=  0.793490898340
      socc( 5)=  0.127435189492
      case (16) ! h2s2
      socc( 1)=  0.856202102739
      socc( 2)=  0.838272107562
      socc( 3)=  2.586129191291
      socc( 4)=  1.622224170289
      socc( 5)=  0.097172428119
      case (17) ! hcl
      socc( 1)=  0.856048863942
      socc( 2)=  0.943560207493
      socc( 3)=  3.290905101058
      socc( 4)=  1.879158515679
      socc( 5)=  0.030327311828
      end select

      end

!! ------------------------------------------------------------------------
!  normalize shell occ. to q_atom = 0, just to make shell_occ_ML 
!! ------------------------------------------------------------------------

subroutine qshnorm(z,nsh,qshref)
      implicit none
      integer nsh
      real*8  z,qshref(10)

      integer i
      real*8  norm, pol, val
      real*8  qshnew(10)     
      
      norm = sum(qshref(1:nsh))

      qshnew(1:nsh) = qshref(1:nsh) * z / norm

      do i=1,nsh
         write(*,'(6x,''socc('',i2,'')='',F16.12)') i, qshnew(i)
      enddo

end

!! ------------------------------------------------------------------------
!  Wiberg in ZDO basis
!! ------------------------------------------------------------------------

subroutine wiberg_zdo(n,ndim,at,rab,P,wb)
      use bascom
      implicit none
      integer n,ndim,at(n)
      real*8 rab(n*(n+1)/2)
      real*8 P(ndim,ndim)
      real*8 wb(n,n)

      real*8 xsum
      integer i,j,k,m,ibmax,imem(n),lin
      character*2 asym
      integer llao(4)
      data llao /1,3,5,7 /
      integer aose(2,n)

      m = 1     
      do i=1,n 
         aose(1,i)=m 
         do k=1,bas_nsh(at(i))
            m= m + llao(bas_lsh(k,at(i))+1)
         enddo
         aose(2,i)=m-1
      enddo

      wb=0
      do i=2,n 
         do j=1,i-1
         xsum=0.0
         if(rab(lin(i,j)).lt.50.0)then
            do k=aose(1,i),aose(2,i)     ! AOs on atom i
               do m=aose(1,j),aose(2,j)  ! AOs on atom j
                  xsum=xsum+P(k,m)**2
               enddo
            enddo
         endif
         wb(i,j)=xsum
         wb(j,i)=xsum
         enddo
      enddo
!     call prmat(6,wb,n,n,'WBO')

      end

